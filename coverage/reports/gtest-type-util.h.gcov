        -:    0:Source:/usr/include/gtest/internal/gtest-type-util.h
        -:    0:Graph:../cov-EasyMath.gcno
        -:    0:Data:../cov-EasyMath.gcda
        -:    0:Runs:1
        -:    1:// Copyright 2008 Google Inc.
        -:    2:// All Rights Reserved.
        -:    3://
        -:    4:// Redistribution and use in source and binary forms, with or without
        -:    5:// modification, are permitted provided that the following conditions are
        -:    6:// met:
        -:    7://
        -:    8://     * Redistributions of source code must retain the above copyright
        -:    9:// notice, this list of conditions and the following disclaimer.
        -:   10://     * Redistributions in binary form must reproduce the above
        -:   11:// copyright notice, this list of conditions and the following disclaimer
        -:   12:// in the documentation and/or other materials provided with the
        -:   13:// distribution.
        -:   14://     * Neither the name of Google Inc. nor the names of its
        -:   15:// contributors may be used to endorse or promote products derived from
        -:   16:// this software without specific prior written permission.
        -:   17://
        -:   18:// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   19:// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   20:// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        -:   21:// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        -:   22:// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   23:// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        -:   24:// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   25:// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   26:// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   27:// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        -:   28:// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   29:
        -:   30:// Type utilities needed for implementing typed and type-parameterized
        -:   31:// tests.
        -:   32:
        -:   33:// GOOGLETEST_CM0001 DO NOT DELETE
        -:   34:
        -:   35:#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
        -:   36:#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
        -:   37:
        -:   38:#include "gtest/internal/gtest-port.h"
        -:   39:
        -:   40:// #ifdef __GNUC__ is too general here.  It is possible to use gcc without using
        -:   41:// libstdc++ (which is where cxxabi.h comes from).
        -:   42:# if GTEST_HAS_CXXABI_H_
        -:   43:#  include <cxxabi.h>
        -:   44:# elif defined(__HP_aCC)
        -:   45:#  include <acxx_demangle.h>
        -:   46:# endif  // GTEST_HASH_CXXABI_H_
        -:   47:
        -:   48:namespace testing {
        -:   49:namespace internal {
        -:   50:
        -:   51:// Canonicalizes a given name with respect to the Standard C++ Library.
        -:   52:// This handles removing the inline namespace within `std` that is
        -:   53:// used by various standard libraries (e.g., `std::__1`).  Names outside
        -:   54:// of namespace std are returned unmodified.
    #####:   55:inline std::string CanonicalizeForStdLibVersioning(std::string s) {
        -:   56:  static const char prefix[] = "std::__";
    #####:   57:  if (s.compare(0, strlen(prefix), prefix) == 0) {
    #####:   58:    std::string::size_type end = s.find("::", strlen(prefix));
    #####:   59:    if (end != s.npos) {
        -:   60:      // Erase everything between the initial `std` and the second `::`.
    #####:   61:      s.erase(strlen("std"), end - strlen("std"));
        -:   62:    }
        -:   63:  }
    #####:   64:  return s;
        -:   65:}
        -:   66:
        -:   67:#if GTEST_HAS_RTTI
        -:   68:// GetTypeName(const std::type_info&) returns a human-readable name of type T.
    #####:   69:inline std::string GetTypeName(const std::type_info& type) {
    #####:   70:  const char* const name = type.name();
        -:   71:#if GTEST_HAS_CXXABI_H_ || defined(__HP_aCC)
    #####:   72:  int status = 0;
        -:   73:  // gcc's implementation of typeid(T).name() mangles the type name,
        -:   74:  // so we have to demangle it.
        -:   75:#if GTEST_HAS_CXXABI_H_
        -:   76:  using abi::__cxa_demangle;
        -:   77:#endif  // GTEST_HAS_CXXABI_H_
    #####:   78:  char* const readable_name = __cxa_demangle(name, nullptr, nullptr, &status);
    #####:   79:  const std::string name_str(status == 0 ? readable_name : name);
    #####:   80:  free(readable_name);
    #####:   81:  return CanonicalizeForStdLibVersioning(name_str);
        -:   82:#else
        -:   83:  return name;
        -:   84:#endif  // GTEST_HAS_CXXABI_H_ || __HP_aCC
    #####:   85:}
        -:   86:#endif  // GTEST_HAS_RTTI
        -:   87:
        -:   88:// GetTypeName<T>() returns a human-readable name of type T if and only if
        -:   89:// RTTI is enabled, otherwise it returns a dummy type name.
        -:   90:// NB: This function is also used in Google Mock, so don't move it inside of
        -:   91:// the typed-test-only section below.
        -:   92:template <typename T>
        -:   93:std::string GetTypeName() {
        -:   94:#if GTEST_HAS_RTTI
        -:   95:  return GetTypeName(typeid(T));
        -:   96:#else
        -:   97:  return "<type>";
        -:   98:#endif  // GTEST_HAS_RTTI
        -:   99:}
        -:  100:
        -:  101:#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
        -:  102:
        -:  103:// A unique type indicating an empty node
        -:  104:struct None {};
        -:  105:
        -:  106:# define GTEST_TEMPLATE_ template <typename T> class
        -:  107:
        -:  108:// The template "selector" struct TemplateSel<Tmpl> is used to
        -:  109:// represent Tmpl, which must be a class template with one type
        -:  110:// parameter, as a type.  TemplateSel<Tmpl>::Bind<T>::type is defined
        -:  111:// as the type Tmpl<T>.  This allows us to actually instantiate the
        -:  112:// template "selected" by TemplateSel<Tmpl>.
        -:  113://
        -:  114:// This trick is necessary for simulating typedef for class templates,
        -:  115:// which C++ doesn't support directly.
        -:  116:template <GTEST_TEMPLATE_ Tmpl>
        -:  117:struct TemplateSel {
        -:  118:  template <typename T>
        -:  119:  struct Bind {
        -:  120:    typedef Tmpl<T> type;
        -:  121:  };
        -:  122:};
        -:  123:
        -:  124:# define GTEST_BIND_(TmplSel, T) \
        -:  125:  TmplSel::template Bind<T>::type
        -:  126:
        -:  127:template <GTEST_TEMPLATE_ Head_, GTEST_TEMPLATE_... Tail_>
        -:  128:struct Templates {
        -:  129:  using Head = TemplateSel<Head_>;
        -:  130:  using Tail = Templates<Tail_...>;
        -:  131:};
        -:  132:
        -:  133:template <GTEST_TEMPLATE_ Head_>
        -:  134:struct Templates<Head_> {
        -:  135:  using Head = TemplateSel<Head_>;
        -:  136:  using Tail = None;
        -:  137:};
        -:  138:
        -:  139:// Tuple-like type lists
        -:  140:template <typename Head_, typename... Tail_>
        -:  141:struct Types {
        -:  142:  using Head = Head_;
        -:  143:  using Tail = Types<Tail_...>;
        -:  144:};
        -:  145:
        -:  146:template <typename Head_>
        -:  147:struct Types<Head_> {
        -:  148:  using Head = Head_;
        -:  149:  using Tail = None;
        -:  150:};
        -:  151:
        -:  152:// Helper metafunctions to tell apart a single type from types
        -:  153:// generated by ::testing::Types
        -:  154:template <typename... Ts>
        -:  155:struct ProxyTypeList {
        -:  156:  using type = Types<Ts...>;
        -:  157:};
        -:  158:
        -:  159:template <typename>
        -:  160:struct is_proxy_type_list : std::false_type {};
        -:  161:
        -:  162:template <typename... Ts>
        -:  163:struct is_proxy_type_list<ProxyTypeList<Ts...>> : std::true_type {};
        -:  164:
        -:  165:// Generator which conditionally creates type lists.
        -:  166:// It recognizes if a requested type list should be created
        -:  167:// and prevents creating a new type list nested within another one.
        -:  168:template <typename T>
        -:  169:struct GenerateTypeList {
        -:  170: private:
        -:  171:  using proxy = typename std::conditional<is_proxy_type_list<T>::value, T,
        -:  172:                                          ProxyTypeList<T>>::type;
        -:  173:
        -:  174: public:
        -:  175:  using type = typename proxy::type;
        -:  176:};
        -:  177:
        -:  178:#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
        -:  179:
        -:  180:}  // namespace internal
        -:  181:
        -:  182:template <typename... Ts>
        -:  183:using Types = internal::ProxyTypeList<Ts...>;
        -:  184:
        -:  185:}  // namespace testing
        -:  186:
        -:  187:#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
